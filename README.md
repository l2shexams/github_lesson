# Лекция по git и GitHub

#### Для 10 математико-программистского профиля Л2Ш

### Москва, 17 мая 2025

###### Лекция подготовлена Муляром Никитой

<hr>

## Репозиторий с урока

https://github.com/NikitaMulyar/git_project_lesson

## Предисловие

Для урока необходимо, чтобы на компьютере было установлено:
- PyCharm 2024.3 и новее
- Python 3.12.x
- git

## Введение

Сегодня мы поговорим про **Системы контроля версий** (Version Control Systems или VCS).

Представьте: вы работаете над новым хобби-проектом — программой, выводящей на экран изображение снежного человека. Как сделать процесс удобным и максимально продуктивным?

Когда появляются новые идеи, хочется быстрее их проверить, изменить код. Но важно при этом сохранить и промежуточные результаты, чтобы затем, если понадобится, к ним вернуться. Например, чтобы сравнить версии и выбрать более удачную.

В определенный момент становится ясно, какой должна быть финальная версия программы. Дальше работа продолжается вместе с другом — и с ним надо поделиться исходным кодом.

Когда каждый из вас захочет поэкспериментировать с результатом со своего устройства, у обоих должен быть доступ к данным.

Потом, когда оба поработали отдельно, получившееся надо объединить в одно целое. И, конечно, совсем не хочется, чтобы все усилия пропали из-за сломавшейся техники.

Тогда на помощь приходят системы контроля версий. Что они делают:

1. Сохраняют код при поломках
2. Хранят много версий кода программы и позволяют легко переключаться между ними
3. Помогают разработчикам обмениваться кодом и редактировать один и тот же код с разных устройств
4. Объединяют результаты труда нескольких разработчиков

Чаще всего используют систему контроля версий Git.

Давайте посмотрим, из чего состоит и как работает эта система.

## Установка и настройка Git

Для установки Git в ОС Linux добавьте в систему пакет Git. Для семейства debian/ubuntu выполните в командной строке команду:

```bash
> sudo apt install git
```

В macOS ситуация похожая. Выполните команду:

```zsh
> brew install git
```

А вот для установки Git для ОС Windows скачайте сборку с [**сайта системы**](https://git-scm.com/) и следуйте документации.

Многие программисты пользуются Git через интерфейс командной строки, но мы с вами рассмотрим вариант работы с системой контроля версий через графический интерфейс. Работа через командную строку более гибкая и позволяет реализовывать некоторые очень сложные сценарии, но нам будет достаточно функций, которые предоставляются графическими обертками для Git.

## Работа в локальном репозитории

Создайте новый проект в PyCharm:

![](https://yastatic.net/s3/lyceum/content/presentation/photo_2021-11-12%2013.24.12.jpeg)

В проекте будет папка venv, если вы решили создать новое виртуальное окружение.

![](https://yastatic.net/s3/lyceum/content/presentation/photo_2021-11-12%2013.23.57.jpeg)

Создайте в папке файл с названием `.gitignore`. В нем с новой строки вы можете прописывать пути до директорий или 
файлов, которые git отслеживать не будет, т.е. они будут храниться только у вас на компьютере (как обычно).

Теперь создадим первый файл нашей программы `program.py` в папке `git_project1` со следующим содержимым:

```python
def main():
    print('My first git program')


if __name__ == '__main__':
    main()
```

И, наконец, инициализируем (создадим новый) в этом каталоге пустой репозиторий Git. 

> ###### Терминология
> **Репозиторием** Git называют каталог (папку, директорию), содержащий отслеживаемые файлы, папки и служебные 
> структуры Git.

Для того чтобы подключить систему контроля версий к проекту, перейдите в пункт меню VCS → Create Git Repository.

![](https://yastatic.net/s3/lyceum/content/presentation/photo_2021-11-12%2013.23.51.jpeg)

Появится диалоговое окно с вопросом, в каком каталоге мы хотим инициализировать репозиторий:

![](https://yastatic.net/s3/lyceum/content/presentation/photo_2021-11-12%2013.23.49.jpeg)

В нем уже будет выбран текущий каталог, который нам и нужен. Так что просто нажимаем кнопку OK.

После этого Git создаст в текущей директории скрытую папку `.git` со служебными структурами репозитория. Сейчас мы не будем ее трогать. Обратите внимание: созданный нами ранее файл `program.py` стал красным. Так отмечаются файлы, не отслеживаемые системой контроля версий.

![](https://yastatic.net/s3/lyceum/content/presentation/photo_2021-11-12%2013.23.47.jpeg)

После инициализации репозитория нам станет доступно меню системы контроля версий. Вызвать его можно с помощью пункта меню View → Tool Windows → Git или сочетанием клавиш Alt + 9, или выбрав в нижней части окна IDE вкладку Git. В нем нас интересует вкладка Log: там хранится история нашего репозитория. Так как мы пока ничего не делали с репозиторием, история пустая.

В Git есть такое понятие, как ветки.

**Ветка** — это именованная версия (направление) разработки программы, с которой сейчас работает программист.

Например, представьте, что вы работаете над программой, у которой уже есть стабильная версия. Вам надо ее изменить, и это можно сделать двумя способами. Чтобы выбрать лучший, не повредив текущему состоянию, можно создать два варианта развития программы — две ветки — с именами **Вариант 1** и **Вариант 2**.

Как только мы создаем репозиторий, появляется автоматически сформированная ветка с названием main — главная ветка 
нашего проекта. В реальной жизни в ней хранится только протестированный код, из которого можно в любой момент времени собрать рабочее, готовое к использованию приложение.

Вы всегда можете **переключаться** между ветками, а каждое подтверждение изменений в терминологии Git называется **коммит** (от англ. Commit).

> ###### Терминология
> **Коммит (commit)** — сохраненное состояние (версия) файлов репозитория.
> 
> **Ветка (branch)** — последовательность коммитов (история изменения состояния репозитория). Каждый коммит в ветке 
> имеет «родителя» (parent commit) — коммит, на основе которого был получен текущий. В репозитории может быть несколько веток (в случаях, когда к одной версии репозитория применяется несколько независимых изменений).
> 
> **Мердж (слияние, merge)** — объединение двух или более веток. В процессе мерджа изменения с указанной ветки 
> переносятся (копируются) в текущую.
> 
> **Мердж коммит (merge commit)** — коммит, который создается автоматически по завершении процесса слияния веток. 
> Мердж коммит содержит в себе все изменения целевой ветки мерджа, которые отсутствуют в текущей (все коммиты целевой ветки, которые начиная с базы слияния, но не включая её).
> 
> **Чекаут (checkout)** — переход на другое (существующее) состояние репозитория (на другой коммит или ветку). При этом 
> все файлы в репозитории возвращаются в состояние, в котором они находились на момент указанного коммита. Если 
> перед переходом в репозиторий были внесены изменения, которые были добавлены в репозиторий, но не попали в коммит, то 
> они будут перенесены «поверх» состояния после перехода.
> 
> **Ребейз (rebase)** — перенос изменений текущей ветки «поверх» другой ветки. При этом все коммиты текущей ветки, 
> которых нет в целевой, удаляются из текущей и заново создаются в целевой ветке (последовательно применяются к состоянию в целевой ветке). Поскольку ребейз пересоздает коммиты заново и меняет существующую историю, его использование не рекомендуется при командной разработке. Ребейз в ветке, над которой работает несколько человек, может привести к потере чужих изменений и/или невозможности корректно выполнить слияние.
> 
> **Реверт (revert)** — отмена внесенных изменений (коммита или группы коммитов). В процессе реверта создается 
> дополнительный коммит, который так же можно отменить при необходимости (вернув репозиторий в изначальное состояние). Реверт мердж коммита позволяет отменить выполненное ранее слияние веток.


Подробнее работа с ветками будет рассмотрена немного позже. Поэтому пока мы будем делать то, что в реальных 
проектах делать очень не рекомендуется (существует множество шуток, связанных с этим): мы будем коммитить в main.

Запомните: по умолчанию Git **не отслеживает** новые файлы в репозитории до того момента, пока мы чётко не укажем ему обратное.

## Отслеживание версий файлов

Сообщим Git, что теперь ему необходимо **отслеживать** файл `program.py`. Кликнем на файле правой кнопкой мыши и в выпадающем меню выберем пункт Git → Add (Для этого действия есть «горячие клавиши» — Ctrl + Alt + A). Цвет, которым написан `program.py`, сменится на зеленый. Зеленый цвет означает, Git увидел новый файл, ни одной версии которого не зафиксировано в репозитории.

![](https://yastatic.net/s3/lyceum/content/presentation/photo_2021-11-12%2013.23.45.jpeg)

Если просто внести изменения в файл, Git никак не отреагирует. Чтобы система сохранила текущую версию программы, ей нужно дать сигнал через **коммит**.

Для этого предназначена команда Git → commit (Ctrl + K). Также можно воспользоваться меню быстрого доступа к командам системы контроля версий (зеленая галочка):

![](https://yastatic.net/s3/lyceum/content/presentation/photo_2021-11-12%2013.23.43.jpeg)

Каждый коммит в Git обязательно сопровождается коротким текстовым сообщением, в котором разработчик описывает внесенные изменения.

Давайте попробуем:

![](https://yastatic.net/s3/lyceum/content/presentation/photo_2021-11-12%2013.23.42.jpeg)

В верхней части окна показываются файлы, которые были изменены или созданы и отслеживаются git. 'Unversioned 
Files' - список неотслеживаемых файлов и директорий. Будьте внимательны: **никогда не выбирайте полностью 
отслеживать все файлы в репозитории**, поскольку есть разного вида файлы, которые не стоит никуда коммитить (venv, .
env, idea и пр.). Однако если вы это сделали, то вспомните про `.gitignore`. Хотя стоит 
отметить, что данные файлы будет трудно удалить из истории версий.

Если вы запустили Git на своем компьютере в первый раз, то у вас не получится сделать коммит, о чем Git снова любезно проинформирует.

![](https://yastatic.net/s3/lyceum/content/presentation/photo_2021-11-12%2013.23.40.jpeg)

Дело в том, что Git любит вежливых разработчиков, и ему надо сначала **представиться**. Вас попросят ввести ваше имя и адрес электронной почты.

А затем нажмите кнопку "Set and commit".

Удалось? Снова перейдем на вкладку Log меню системы контроля версий, где увидим наш коммит, а также суть внесенных изменений и некоторую дополнительную информацию:

![](https://yastatic.net/s3/lyceum/content/presentation/photo_2021-11-12%2013.23.37.jpeg)

Ура! Наша первая версия зафиксирована. **Коммит** получился.

У каждой зафиксированной версии в Git есть свой идентификатор, называемый **хэшом**. Посмотреть часть хэша коммита можно в правой нижней части вкладки Log после выбора интересующего коммита, а скопировать целиком — после клика правой кнопкой мышки на коммите в левой части вкладки Log и выбора пункта меню Copy Revision Number. У вас он будет уникальный — последовательность букв и цифр, похожая на 17b655ee91ed6e3483b8bd7e642f2793f7815b33.

Рядом с нашим коммитом мы можем увидеть две бирочки: желтую и зеленую. Зеленая — ветка main, желтая — HEAD.

HEAD — это своего рода указатель. Он сообщает нам, на какой версии мы сейчас находимся и связана ли она с веткой.

В истории версий мы видим:

- Уникальный идентификатор (**хэш**) коммита (версии)
- Направление коммита — из какой ветки в какую мы сохраняем изменения. Сейчас мы сохранили из HEAD в main
- Автора изменения
- Дату изменения
- Детали изменений
- Комментарий, который написал автор коммита

Обратите внимание, что файл `program.py` в обзоре проекта перестал быть зеленым. Это означает, что в репозитории хранится последняя версия файла.

Теперь внесем изменения в файл `program.py` и попробуем зафиксировать следующую версию.

Изменим содержимое файла `program.py` на следующее:

```python
def main():
    print('My first git program')
    print('And I change it every day')

    
if __name__ == '__main__':
    main()
```

Убедимся, что Git отследил изменение файла: цвет файла изменился на синий. Это означает, что в отслеживаемом файле есть незафиксированные изменения. А в редакторе кода поле рядом со строкой, которую мы добавили, стало зеленым, сигнализируя, что это новый код, который пока не сохранен в репозитории:

![](https://yastatic.net/s3/lyceum/content/presentation/photo_2021-11-12%2013.24.11.jpeg)

Теперь у нас есть несколько вариантов действий:

- Отменить изменения — Git → Uncommited Changes → Rollback (стрелочка разворота на меню быстрого доступа). Эта команда откатит файл к последней зафиксированной версии. *Вы можете проверить это самостоятельно*
- Зафиксировать изменения — Git → Commit

Зафиксируем новую версию с комментарием "New day — new print", а затем посмотрим статус и обновленную историю коммитов.

Как видно из истории, теперь в нашем репозитории есть две зафиксированные (разработчики говорят **закоммиченные**) версии: одна — текущая, на которой есть указатель HEAD (с этой версией мы сейчас работаем), и вторая — наш первый коммит.

Переключимся на предыдущую версию. Для этого выберем в списке предыдущий коммит, кликнем на нем правой кнопкой мыши и выберем пункт меню Checkout Revision.

Как видим, Git откатил файл к предыдущей версии: в программе нет добавленного нами ранее второго print.

Проверим статус в истории Git: метка HEAD находится не на последнем коммите, то есть мы работаем не с последней версией кода в этой ветке. Этого лучше избегать, чтобы не получалось лишних ветвей и высокой степени неопределенности.

Для продолжения работы вернемся к последнему коммиту, выбрав его в истории изменений и переключившись с помощью 
команды Branch 'main' → Checkout, и убедимся, что мы снова работаем с наиболее актуальной версией файла.

![](https://yastatic.net/s3/lyceum/content/presentation/photo_2021-11-12%2013.24.09.jpeg)

Итак, мы вернулись к последним изменениям.

Возможность откатиться к предыдущей версии файла бывает крайне полезна: например, когда нужно увидеть, как программа работала до последних изменений. Однако постоянное переключение между коммитами не слишком удобно, особенно если нужно отследить изменения многих файлов. Приходится где-то хранить старую и новую версии, как-то искать между ними расхождения, что само по себе — задача трудоемкая.

В PyCharm есть более мощный инструмент для поиска различий в версиях Git. Он вызывается командой Git → Current file → Compare with Revision..., который позволяет сравнить текущую версию файла с версией из любого другого коммита (сначала надо выделить нужный файл в обзоре проекта).

Сравним наши два коммита:

![](https://yastatic.net/s3/lyceum/content/presentation/photo_2021-11-12%2013.24.07.jpeg)

Мы видим исходный код каждой из версий, а также строки, которыми они различаются.

> ###### Терминология
> **Дифф (diff)** — разница двух состояний (коммитов, веток, подготовленных или модифицированных файлов).

## Начало работы с удаленным репозиторием

> ###### Терминология
> **Локальный репозиторий** — это репозиторий, который размещен на конкретной машине разработчика. 
> 
> **Удаленный репозиторий** (он же сетевой репозиторий) — это репозиторий, расположенный на удаленном сервере, в 
> который вносят изменение все разработчики проекта.

В произвольный момент времени состав веток и коммитов во всех репозиториях может различаться, но в некоторые оговоренные моменты времени (как правило, перед началом работы над задачей, после окончания работы над задачей и в конце дня) разработчики синхронизируют свои локальные репозитории с удаленным.

Есть два варианта синхронизации изменений:

> ###### Терминология
> **Пулл (pull)** — слияние состояния удаленного репозитория и локального (обычно — в отдельной ветке). Пулл может 
> выполняться как для одной и той же ветки (с одинаковым именем), так и для разных. Пулл являет собою обычный мердж, но целевая ветка при этом находится не в том же репозитории, в котором выполняется пулл, а в удаленном. Как следствие, при пулле так же создается мердж коммит, пулл можно отменить (заревертить) и в его процессе может возникнуть мердж конфликт.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/481/6e4/c2c/4816e4c2cc291379aa0fba18497bf71b.png)

> ###### Терминология
> **Пуш (push)** — обратный пуллу процесс. При пуше изменения из локального репозитория переносятся в удаленный. Пуш 
> обновляет состояние текущей ветки в удаленном репозитории и не является мерджем (не создает дополнительные коммиты и не может привести к конфликтам). Если в ветке удаленного репозитория присутствуют коммиты, которых нет в локальном репозитории, сигнализируется ошибка о несовпадении истории изменений (non fast-forward merge), пуш выполнить не получится. В таком случае необходимо сначала синхронизировать состояние локального репозитория (получить недостающие коммиты с помощью пулла), и только после этого повторить процесс пуша.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/e8a/ffe/fc7/e8affefc729a13ebb8073ac61f4e1aa3.png)

> ###### Терминология
> **Мердж конфликт (merge conflict)** — ситуация, когда при слиянии веток в один или несколько файлов вносились 
> независимые изменения. В некоторых случаях (например, если изменялись разные, непересекающиеся части одного файла) 
> git способен самостоятельно решить, как выполнять слияние таких файлов. Если автоматически это сделать не удалось — возникает конфликт. В таком случае необходимо самостоятельно указать, как выполнять слияние конфликтующих версий (решить конфликт, resolve merge conflict). Изменения, внесенные в процессе решения конфликта, автоматически попадают в мердж коммит.

Нередко возникает необходимость обновить информацию о состоянии удаленного репозитория (существующих ветках и 
коммитах в них) без выполнения слияния (пулла). Такой процесс называется **фетчем (fetch)**. Таким образом, пулл 
является комбинаций фетча и мерджа: сперва обновляется информация о состоянии целевой ветки в удаленном репозитории, а затем ее изменения вливаются в текущую ветку в локальном репозитории.

Перед отправкой своих изменений разработчик должен объединить (часто говорят «смержить» от английского слова merge) их с изменениями, подтянутыми с сервера.

Чаще всего для ведения сетевых репозиториев используют сервисы GitHub, Gitlab или Bitbucket. На этом уроке мы будем использовать GitHub, потому что он распространен среди разработчиков ПО с открытым кодом, и вы наверняка с ним неоднократно столкнетесь. Кроме того, хорошо выглядящий профиль на GitHub с большим числом полезных коммитов в свои и чужие открытые проекты — это, считайте, половина резюме успешного разработчика.

Поэтому сейчас мы создадим себе аккаунт на GitHub.

## Создание аккаунта на GitHub

Первым делом перейдите по [**ссылке**](http://github.com/join). Заполните Username — ваше имя пользователя в GitHub. Это **ник**, по нему вас будут узнавать. Имя пользователя видят все посетители ваших репозиториев.

Укажите адрес электронной почты, придумайте пароль и нажмите кнопку.

Затем выберите Unlimited public repositories for free. Остальные галочки пока не нужны.

На третьем шаге пока можно ничего не трогать, а просто нажать Submit.

Теперь проверьте электронный почтовый ящик: вам придет ссылка для подтверждения аккаунта.

Войдя на сайт, нажмите на ссылку [**Start a project**](http://github.com/new), чтобы завести свой первый сетевой репозиторий. Введите имя репозитория git_project1 и нажмите Create repository.

Поздравляем — ваш первый репозиторий создан!

Сохраните ссылку на него — она имеет вид `https://github.com/<ваш username>/git_project1.git.` Работая с примерами, не забывайте подставлять в ссылку свое имя пользователя.

После урока стоит почитать [**инструкцию**](https://guides.github.com/activities/hello-world/) GitHub для новых участников.

## Синхронизация с сетевыми репозиториями

Давайте попробуем выгрузить наш локальный в новый сетевой репозиторий на GitHub. Имейте в виду, что к локальному репозиторию можно подключить несколько удаленных. Сетевые репозитории часто называют **remote-репозиториями**.

Для управления remote-репозиториями используется команда Git → Manage remotes. Подключим к нашему локальному 
репозиторию удаленный, добавив его в появившемся меню с именем origin. В нашем примере мы подключаем репозиторий с 
именем git_project1:

![](https://yastatic.net/s3/lyceum/content/presentation/photo_2021-11-12%2013.24.05.jpeg)

Теперь загрузим изменения из нашего локального репозитория в сетевой (удаленный) репозиторий. Для этого используется 
команда Git → Push (Ctrl + Shift + k). В появившемся окне мы увидим, какие коммиты отправляются из локального в удаленный.

![](https://yastatic.net/s3/lyceum/content/presentation/photo_2021-11-12%2013.24.03.jpeg)

При выполнении этих действий будут запрошены ваши логин GitHub и токен авторизации. Токен можно получить в Developer 
Settings в настройках профиля.

После успешной отправки в удаленном репозитории будет создана ветка main, в которую запишутся все наши коммиты для 
локальной ветки main.

Вернитесь в веб-интерфейс GitHub, открыв в вашем браузере ссылку на репозиторий (`https://github.
com/имя_пользователя/git_lesson_repository.git`), и убедитесь, что в веб-интерфейсе появился наш файл `program.py` из 
ветки main.

![](https://yastatic.net/s3/lyceum/content/images/second-year/git-1/git-1-16.png)

Обратите внимание на ссылку Commits (2) в верхней части репозитория. Перейдя по ней, вы увидите все коммиты, которые 
мы сделали в ветке main.

Важно: при загрузке ветки в удаленный репозиторий копируется не только актуальное состояние ветки, но и вся история коммитов в эту ветку, что позволяет всем пользователям удаленного репозитория легко восстановить хронологию «развития» вашей программы.

![](https://yastatic.net/s3/lyceum/content/images/second-year/git-1/git-1-17.png)

Если мы перейдем во вкладку Log меню системы контроля версий, то увидим, что рядом с нашим последним коммитом появилась еще одна фиолетовая бирочка — знак того, что это последний коммит, зафиксированный в удаленном репозитории.

Давайте сделаем еще один коммит и убедимся, что после этого бирочки HEAD и main передвинулись, а origin осталась на месте.

![](https://yastatic.net/s3/lyceum/content/presentation/photo_2021-11-12%2013.24.01.jpeg)

Запушим изменения в удаленный репозиторий.

А теперь с использованием веб-интерфейса GitHub сымитируем изменения удаленного репозитория другим участником разработки (или нами же, но с другого рабочего места). Кликнем в просмотре репозитория на файл `program.py`, затем на иконку редактирования файла и добавим в файл, какую-либо новую информацию, например еще один print:

```python
def main():
    print('My first git program')
    print('And I change it every day')
    print('Again')
    print('UFO came and added this line')

    
if __name__ == '__main__':
    main()
```

Добавим комментарий к нашему изменению, так как при изменении файлов через веб-интерфейс GitHub создает в нашем репозитории полноценные коммиты.

![](https://yastatic.net/s3/lyceum/content/images/second-year/git-1/git-1-18.png)

Для получения изменений из удаленного в локальный репозиторий используется команда Pull, в PyCharm вокруг нее есть «обертка» в виде меню Git → Update Project (Ctrl + T или стрелочка на «юго-запад» в меню быстрого доступа). Для большинства случаев подойдут настройки по умолчанию.

![](https://yastatic.net/s3/lyceum/content/presentation/photo_2021-11-12%2013.23.59.jpeg)

После того как мы «затянем» изменения из удаленного репозитория в локальный, у нас появятся все коммиты сделанные с других рабочих мест, и все файлы проекта приведутся к актуальным версиям.

## Клонирование сетевого репозитория

Теперь представим, что локального репозитория у вас нет (например, вы начали работать с другого компьютера или к вашему проекту присоединился еще один разработчик). Есть только ссылка на удаленный репозиторий. В этом случае репозиторий необходимо **склонировать**.

Для этого есть команда Git → Clone.

![](https://yastatic.net/s3/lyceum/content/presentation/photo_2021-11-12%2013.23.55.jpeg)

С помощью этой команды вы сможете:

1. Указать адрес удаленного репозитория
2. Указать папку на локальном диске, в которую его необходимо склонировать
3. Проверить доступность репозитория
4. Залогиниться в удаленный Git-репозиторий

Выполняя эту команду, Git проверяет существование удаленного репозитория. Если репозиторий есть, то создается 
локальный репозиторий, и в него подтягиваются изменения из ветки, на которую указывает HEAD. Как правило, это main 
удаленного репозитория. Удаленный репозиторий добавляется и как upstream (с возможностью загрузки), и как downstream (с возможностью выгрузки), и получает имя origin.

Попробуйте склонировать свой удаленный репозиторий в другую локальную папку.

## Работа с git в консоли

По этой теме есть отдельный урок: [Тык](https://yltheory.notion.site/133d7190f28b81d3a937cf50bcd57fa5)

## Командная работа в git и GitHub: Ветки

Мы уже немного затронули тему о **ветках** в Git. Настало время внимательней разобрать это понятие.

Если бы система контроля версий ограничивалась только ведением истории коммитов, то она бы никак не помогла нескольким разработчикам работать с одним репозиторием. Или одному разработчику — над несколькими задачами в одном.

Для всего этого (и не только) в Git и существуют ветки. Ветки позволяют:

- Давать имена версиям
- Иметь одновременно несколько **рабочих** версий (рабочей версией называется та, над которой в определенный момент времени трудится разработчик)
- Объединять результаты деятельности нескольких разработчиков

Допустим, у нас есть программа, последняя закоммиченная версия которой выглядит так:

```python
def my_superfunction():
    print('What an awesome print!')


def main():
    print('My first git program')
    print('And I change it every day')
    print('Again')
    print('UFO came and added this line')
    my_superfunction()


if __name__ == '__main__':
    main()
```

Мы хотим создать версии нашей программы, в которой функция my_superfunction ведет себя по-другому, например, одна 
выводит надпись Hello, python!!!, другая — KEstavit2, но старую версию мы тоже хотим сохранить.

Сначала заведем новую ветку программы и сразу на нее переключимся. Это можно сделать через пункт меню VCS → Git → 
Branches → New Branch (или Ctrl + Shift + `). В появившемся окне введем имя нашей новой ветки, например, newBranch, оставим галочку, которая сразу осуществляет переключение на новую ветку при создании нетронутой.

![](https://yastatic.net/s3/lyceum/content/images/second-year/git-2/git-2-1-create-branch.png)

Посмотрим на вкладку Log меню системы контроля версий. Обратите внимание, что на последнем коммите появилась еще 
одна зеленая бирочка, которая говорит о том, что мы находимся на развилке и в этом месте код двух веток main 
и newBranch совпадает.

![](https://yastatic.net/s3/lyceum/content/images/second-year/git-2/git-2-2.png)

Поменяем код нашей функции и закоммитим изменения.

![](https://yastatic.net/s3/lyceum/content/images/second-year/git-2/git-2-3.png)

При совершении коммита видно, что изменения фиксируются в ветку newBranch.

Давайте вернемся в main. В Logs в меню системы контроля версии выберем последний коммит ветки main, кликнем на нем правой кнопкой мышки и выберем Branch 'main' → Checkout.

Создадим еще одну ветку, назовем ее demobranch.

Внесем изменения в функцию my_superfunction, чтобы она выводила текст KEstavit2, и закомитим изменения.

![](https://yastatic.net/s3/lyceum/content/images/second-year/git-2/git-2-4.png)

По логам видно, что у нас есть три ветки: main, newBranch и demobranch. Demobranch — текущая активная ветка, то, что 
мы находимся в ней, подтверждается указателем HEAD. Также есть ветка newBranch, у которой с demobranch общий источник кода — последний на текущий момент коммит ветки main.

Для того чтобы переключиться в нужную ветку, надо кликнуть на последнем коммите этой ветки и выбрать пункт меню Branch 'имя_ветки' → Checkout (это можно сделать и через меню: VCS → Git → Branches).

Теперь удалим неиспользуемую ветку demobranch командой VCS → Git → Branches → demobranch → Delete.

Теперь мы умеем создавать и удалять ветки, а также переключаться между ветками.

Версии программы, зафиксированные в разных ветках, можно сравнивать между собой с помощью команды VCS → Git → Compare with Branch. Давайте сравним `program.py` из ветки newBranch, в которой мы сейчас находимся, и main.

![](https://yastatic.net/s3/lyceum/content/images/second-year/git-2/git-2-5.png)

Обратите внимание: создавая ветку, мы **получаем полную** копию ветки, в которой находились в этот момент.

Для закрепления успехов перейдем на ветку main, создадим новую ветку addAuthorBranch, и добавим в начало нашей программы комментарий с именем автора:

```python
# KEstavit2
def my_superfunction():
    print('What an awesome print!')
```

Закоммитим изменения.

Затем снова вернемся в main, создадим ветку printOne, в которой добавим в конец функции main код:

```python
print(1)
```

Снова закоммитим изменения. После проделанной работы Log системы контроля версий должен выглядеть примерно вот так:

![](https://yastatic.net/s3/lyceum/content/images/second-year/git-2/git-2-6.png)

## Объединение (слияние) изменений

Итак, Git позволяет независимо разрабатывать несколько версий программы в разных **ветках** одного большого дерева.

Теперь разберемся, как из двух веток собрать единую версию. Попробуем получить программу как с указанием авторства из ветки addAuthorBranch, так и с печатью единицы из ветки printOne.

Для объединения нескольких веток (merge) в одну, нам необходимо перейти в ветку, в которую мы хотим влить изменения. Пусть это будет ветка printOne. Выберите в Log последний коммит ветки addAuthorBranch, кликните на ней правой кнопкой мышки и выберите команду Branch 'addAuthorBranch' → Merge into Current.

![](https://yastatic.net/s3/lyceum/content/images/second-year/git-2/git-2-7.png)

В Logs мы увидим, что у нас соединились две ветки в одну, а сам код — результат объединения этих веток. Влейте ветку newBranch в printOne.

Если мы зайдем на GitHub, мы увидим, что изменения, которые мы делали, там не отразились. Это нормально, ведь все 
изменения мы делали локально. Давайте запушим нашу ветку printOne:

![](https://yastatic.net/s3/lyceum/content/images/second-year/git-2/git-2-8.png)

После этого ветка printOne и коммиты из нее попадут в удаленный репозиторий. А у нашей ветки printOne на вкладке Logs появится фиолетовая бирочка и информация о том, что тот же код находится в удаленном репозитории в ветке origin/printOne.

## Решение конфликтов

Не всегда объединение веток проходит гладко. Бывает, что программисты (или один программист в разных ветках) вносили изменения в одну и ту же строку кода, поэтому при объединении изменений возникнет конфликт, и объединение веток не будет считаться успешным до тех пор, пока этот конфликт не будет решен. Давайте смоделируем такую ситуацию.

Переключимся на ветку main и создадим там новый файл `conflict_test.py` вот с таким кодом:

```python
print("Hello Git!")
print("Hello PyCharm!")
```

Добавим его к отслеживанию и закоммитим.

Создадим новую ветку lowercase (VCS → Git → Branches → New Branch, оставим галочку для переключения на новую ветку), и, стоя на ней, изменим наш файл следующим образом:

```python
print("hello git!")  # маленькие буквы
print("hello pycharm!")  # маленькие буквы
```

Сделаем коммит. После этого переключимся на ветку main, убедимся, что файл вернулся к изначальной версии, и создадим 
еще одну ветку uppercase. Стоя на ней, изменим файл следующим образом:

```python
print("HELLO GIT!")  # большие буквы
print("HELLO PYCHARM!")  # большие буквы
```

Снова зафиксируем версию. Вернемся на ветку main и вольем в нее изменения из ветки lowercase. Слияние должно пройти 
успешно, а на ветке main появятся маленькие буквы. После этого выполним слияние с веткой uppercase. Теперь возник конфликт.

![](https://yastatic.net/s3/lyceum/content/images/second-year/git-2/git-2-9.png)

Нам показывается перечень файлов, в которых изменения затрагивают одни и те же строки. У нас есть несколько вариантов действий:

1. Accept Yours — оставить версию строк, которые находятся в текущей ветке (в которую вливаются изменения)
2. Accept Theirs — заменить все конфликтные строки на новую версию из вливаемой ветки
3. Merge — решить конфликт в ручном режиме. Это наиболее безопасный вариант

![](https://yastatic.net/s3/lyceum/content/images/second-year/git-2/git-2-10.png)

При выборе Merge откроется окно:

- Левая часть — текущая версия файла на ветке, в которую вливаются изменения
- Правая часть — версия файла на ветке, откуда вливаются изменения
- Центральная часть — версия, предлагаемая Git при попытке автоматического слияния, может быть основана на предыдущих версиях файла

Тут есть быстрые кнопки для принятия левой (Accept Left), правой (Accept Right) и центральной части (Apply). Также можно отменить слияние (Abort). Какую часть выбрать — решает разработчик. Еще он может редактировать центральную часть, создав новую версию файла. Решите конфликт любым способом.
